conventional commits [[cite:&nil]]o are a standard for formatting
commit messages. they look like this.

#+BEGIN_SRC
(feat) add a new dialog for listing reports
#+END_SRC

This is actually quite crucial to a project as it makes it
possible to comprehend the repo history with one line logs.

There are a few basic ones in the standard, but I have expanded
on them to encompass all the scenarios I encounter.

To really understand the power of conventional commits you have
to consider the tooling. What if it was possible to generate
release notes entirely from commits ?

Pythonsh does!

Here are the standard elements with my extension.

- (feat) new features. A oneliner is either sufficient or some prose is added below
  the main commit line.
- (fix) this is primarily for development. They belong on feature branches.
  fixes are corrections to code that has not been released yet.
- (bug) bugs are defects in code that has been released. They need to be
  included in the release notes
- (issue) issues are bugs that have been reported by users and have a ticket assigned.
- (sync) a fast-forward. This is done only on the trunks: develop and main where they
  are histories that are stable, and consist entirely of merges.
 
  The other use case is for third party submodules. since .gitmodules and git internals
  remember the commit sync'd its not a good idea to introduce local commits. That will
  get ugly.

  For (syc) is is critical that the date be in the one-liner as dependencies are
  being updated and this has a large impact on the release.

- (pull) for working on feature branches, pull is for pulling changes into the
  feature branches
- (merge) merge is for pulling from and to the trunk.
- (release) releases are alpha and beta releases. The actual release process with
  git flow release start is more complex and is documented below
- (alpha) both tag and possibly a commit this indicates it's a beta candidate
  and the developer wants to tag/commit to establish a baseline
- (beta) This is on the develop trunk and indicates that this is a point from
  which beta_fix and beta_<feature branch> should be branched off this point.

This systematic annotating of the history makes it possible to understand
the changes far beyond cryptic and poor commit messsages.

This also allows for tools that help insert commit messages, and generate
entire release notes into merge commits and the like.

*** Package Managment, Test, and Build

The envronment workflow is a progression from dev -> test -> release.

It starts with the version control workflow, where a developer has
a feature branch checked out. Thee developer is using the "dev"
virtual environment and he bangs on the code until it looks good
and passes all tests.

#+BEGIN_SRC bash
switch_dev
./py.sh test
#+END_SRC

During development new packages may be added, or newer versions
pulled in.

#+BEGIN_SRC bash
./py.sh update
./py.sh test
#+END_SRC

When the developer things things are ready he switches to the test
virtual environment.

He performs a:

#+BEGIN_SRC bash
switch_test

,# install the latest package set and test.
./py.sh all
./py.sh test
#+END_SRC

Inevitably some bugs might pop up so he fixes them up and continues
working until the tests are passed.

When the tests pass he is staged for release. He performs a build
or a build-set constructing packages. If the build goes well then
an alpa tag is created.

#+BEGIN_SRC bash
./py.sh build

,# commit files, especially Pipfile, and Pipfile.lock

,# squash the feature branch down to a single commit and give it
,# in conventional commit format

./py.sh tag-alpha "feature" "message"
#+END_SRC

At this point the feature branch is closed with a finish.

#+BEGIN_SRC bash
git flow feature finish COMMIT
#+END_SRC

** Pythonsh version control features

Circling back to Version Control Practices we begin with the version
control features of pythonsh.

There are several aliases built into the zshrc file for quick git commands

#+BEGIN_SRC bash
alias status='git status'
alias diff='git diff'
alias stat='git diffstat'
alias commit='git commit'
alias ff='git pull'
alias pull='git pull --no-ff'
alias push='git push'
alias add='git add'
alias co='git checkout'
alias branch='git branch'
alias merge='git merge --no-ff'
#+END_SRC


*** fast-forward vs. merge

fast-forward with git seems slick, all the commits get appended and
it's flashy. However it's a disaster in most cases for this simple reason:

fast-forward can't be undone. Your stuck with those commits without some
really nasty git hacking. A merge on the other hand can be reverted.

The best place for a ff, is when you are pulling a submodule upstream and
you dont want to introduce local commits, and you have no ownership of the
code.

For this reason the pull and merge aliases add the "--no-ff" option
to force a commit to be created.

*** The status alias

Here is an example of the status command output:

#+BEGIN_SRC bash
<devil> [pastepipe_dev] pastepipe:develop(*) -> status
On branch develop
Your branch is up to date with 'origin/develop'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
  modified:   Pipfile.lock
  modified:   pyproject.toml

Untracked files:
  (use "git add <file>..." to include in what will be committed)
  dist/
  src/pastepipe.egg-info/

no changes added to commit (use "git add" and/or "git commit -a")
<devil> [pastepipe_dev] pastepipe:develop(*) ->
#+END_SRC

*** Overview of pythonsh git functions

- track <1> <2>
- tag-alpha <feat> <msg>
- tag-beta  <feat> <msg>
- info
- verify
- status
- fetch
- pull
- staged
- merges
- history
- summary
- delta
- ahead
- behind
- graph
- upstream
- sync

*** Details of pythonsh git functions

- track = sets up upstream branch tracking. This is a simple utility
- tag-alpha

when development has reached an alpha state for a feature and the
programmer wants to create a milestone after quashing he creates
a alpha tag. This command ensures proper formatting since the
prefixes of the tags is used by the tools for filtering etc.

- tag-beta

Beta tags are for develop trunk milestones. Beta tags are
for building in test.

*** info

#+BEGIN_SRC bash
<devil> [pastepipe_dev] pastepipe:develop(*) -> ./py.sh info
,*  develop 41eb5d6 [origin/develop] (fix) update the pythonsh infrastructure
  main    384168c [origin/main] (pull) pull latest pythonsh
<devil> [pastepipe_dev] pastepipe:develop(*) ->
#+END_SRC

py.sh info shows the stauts of the branches. this is a very handy
command.

*** track

#+BEGIN_SRC bash
track <1> <2>  = set upstream tracking 1=remote 2=branch
#+END_SRC

sometimes you need to set the upstream for a branch. track makes this easy.

*** fetch & pull

#+BEGIN_SRC bash
fetch      = fetch main, develop, and current branch
pull       = pull current branch no ff
#+END_SRC

fetch  retrieves the commits from upstream but does not merge
them. pull is basically fetch + merge.

*** staged

#+BEGIN_SRC bash
staged     = show staged changes
#+END_SRC

show staged changes. Note that git diff showing the unstaged changes
is a shell alias.

*** The advanced view into repository

-merges = show merges only
-history = show commit history
-summary= show diffstat of summary between feature and develop or last release and develop
-delta = show diff between feature and develop or last release and develop
-graph = show history between feature and develop or last release and develop
-upstream = show upstream changes that havent been merged yet

*** ahead and behind

- ahead
- behind

The most powerful feature is "agains the parent". What this means is
that pythonsh detects if it's on a feature branch, the develop trunk,
or the main trunk.

- ahead
 - if on a feature branch it's a log develop -> feature
 - if on the develop branch it's a diff from main -> develop
 - if on main it's a diff from the last tag -> main
- behind
 - if on a feature branch its a log of what is in develop but not in feature
 - if on a develop branch it shows what is in main, but not develop
 - if on main it looks at the last tag

This intelligence means a single command can be used in three
different contexts with no additional arguments.

- sync = merge from the root branch commits not in this branch no ff

sync is a tool to pull changes from the parent into the current branch. This
is used for when development work on the develop trunk needs to be merged
into the feature branch.

** Release

The release process is designed to test the package and
integration or black box test the functionality of the
package.

*** building

Building should be done in an isolated environtment. tox allows
for tests and such to execute in different environments but this
will dissapear as older python is phased out.

Clearly the most important thing is to focus on virtual environments
where seperate environments can be maintained in a peristent way
mirroring the different environments, dev, test, and release that
the development evironment dictates.


*** Virtual Environments

Python package management takes place in virtual environments.
These are directories that have a python built from source
and a set of installed packages.

When you "activate" a virtual environment and your shell
is correctly set you can execute programs, including
python, in that environment.

**** Virtual Environment Stucture

A project has four virtual environments

- dev: for development
- test: for pre-release testing
- build: for building a release
- release: for testing release packages

The build environment is created and destroyed
automatically. The release environment is
created as needed.

the "dev" and "test" environments are the commonly
used ones. With the shell setup by py.sh typing

- "switch_dev" = switch to development environment
- "switch_test" = switch to test environment

**** Virtual environment creation

The environments are created by two commands:

- ./py.sh project-virtual
- ./py.sh bootstrap

The "project-virtual" command creates the
virtual environments according to the settings
in python.sh

**** python.sh

python.sh is the master file for pythonsh.
It contains all the variables needed to
generate python files.

The idea is that there is one master file,
and all the other files are generated from
it so they are all synchronized.

Unfortunately python has numerous redundancies
so syncing them up is key, and best done
with a single master file.

Here is an example from pythonsh itself:

#+BEGIN_SRC bash
,# pythonsh configuration file
VERSION=0.14.0

PACKAGES=pyutils
SOURCE=.

BUILD_NAME=pythonsh

DOCKER_VERSION="0.1.0"

VIRTUAL_PREFIX='pythonsh'
PYTHON_VERSION='3.12'
#+END_SRC

- VERSION = the version of the repository
- PACKAGES = packages that comprise the project
- SOURCE = the directory containing the package sources. it is typically: "src/"
- BUILD_NAME = the name of the built packages
- VIRTUAL_PREFIX = the prefix for the virtualenvs. pythonsh = "pythonsh_dev" etc...
- PYTHON_VERSION = what python version to install/use
 
From this the following packages are generated:

- pyproject.toml = PEP517 build template. contains build system directives and runtime dependencies
- Pipfile = Dependency management. sections for repositories, dependencies, and other variables.

When the virtual environments are created the latest possible PYTHON
matching the PYTHON_VERSION is installed. This is done
automatically. If a interpreter has already been built for that
version it is re-used.

Then the virtualenvs are created by

#+BEGIN_SRC bash
./py.sh project-virtual
#+END_SRC

This creates VIRTUAL_PREFIX-{dev,test}

Then the environment is bootstrapped.

**** boostrap

#+BEGIN_SRC bash
./py.sh bootstrap
#+END_SRC

There are many steps to a bootstrap

- The pip command is upgraded, pipenv is installed
- ./py.sh minimal which installs only the packages needed by pythonsh itself
- then a search is made of the source directories for .pypi and Pipfile

This is unique to pythonsh. Normally all Pipfile instances are
singluar and at the root of the tree. However pythonsh is built to
find fragments of Pipfile in source directories, and installed
packages.

The .pypi fils define repositories. Typically for open-source projects
only the central pypi repository is used. However for commercial
projects private artifact repositories are used as well.

- now all the .pypi repos and fragements are merged by the highest version

This merging process reduces tangled dependencies by syncing all the
dependencies at the teir 1 packages.

- The root Pipfile is written with the packages are installed.

- A second pass then searches installed packages for fragments and merges those

This second pass allows us to gather Pipfile fragments from installed
packages from the first pass.

- Now the final install takes place with all the teir-1 and teir-2 dependencies synced.

- at both stages vulnerability checks are performed.

- finally pyproject.toml is written for the PEP517 build "build" module.

The pyproject.toml build file contains all of the information needed to build
the package.

It is not currently possible to specifiy additional repositories with
a setuptools backend in pyproject.toml. This means that if there are
private repositories it's not possible to specify the dependencies.

When all of the packages are on pypi a dependencies list will be written
to pyproject.toml. If there are other repositories dependencies will be
supressed but the rest of the file will be written.

This is the boostrap process. The end result is that the active
virtualenv will contain a highly homogenous package set for the
project.

Actually pyproject.toml is not generated until a package build
is performed but the two files: Pipfile and pyproject.toml share
a context.

*** Sources

The next step is to get the source code into the virtualenv.
There is a way to make it possible by using "editable" packages,
however I prefer a second approach. It is possible to put ".pth"
packages into site-packages in the virtual environment.

#+BEGIN_SRC bash
show-paths = list .pth source paths
add-paths  = install .pth source paths into the python environment
rm-paths   = remove .pth source paths
site       = print out the path to site-packages
#+END_SRC

- show-paths: shows all the paths in the virtual environment
- add-paths: installs a pth file generated from python.paths in the repo root
- rm-paths: removes the .pth file
- site: prints out the virtualenv site-packages directory location

Although some would discourage .pth files they are ultimately far
more flexible than editable packages. They can contain both absolute
and relative paths.

*** Python commands

#+BEGIN_SRC bash
test    = run pytests
python  = execute python in pyenv
repl    = execute ptpython in pyenv
run     = run a command in pyenv
#+END_SRC

The python commands include all of the basic functionality for python
development.

- test = run unit tests
- python = run a python file
- repl = run a ptpython interactive repl
- run = run a command in the virtual environment

*** Package commands

#+BEGIN_SRC bash
versions   = display the versions of python and installed packages
locked     = update from lockfile
all        = update pip and pipenv install dependencies and dev, lock and check
update     = update installed packages, lock and check
remove     = uninstall the listed packages
list       = list installed packages
#+END_SRC

- versions = display the versions of installed packages
- locked = update the lockfile, which is a file of pinned packages
- all = update pip, pipenv, and install packages including dev packages
- update = update packages to the latest possible versions
- remove = remove a package
- list = show all installed packages in a dependency graph

*** Release Commands

#+BEGIN_SRC bash
check      = fetch main, develop from origin and show log of any pending changes
start      = initiate an EDITOR session to update VERSION in python.sh, reload config,
             snapshot Pipfile if present, and start a git flow release with VERSION

             for the first time pass version as an argument: "./py.sh start 1.0.0"

             if you encounter a problem you can fix it and resume with ./py.sh start resume [pipfile|commit]
             to resume at that point in the flow.
release    = execute git flow release finish with VERSION
upload     = push main and develop branches and tags to remote
#+END_SRC

- check = performs checks to make sure that there are no unmerged upstream changes

The check looks for a dirty repository, unmerged upstream commits, and vulnerable
packages.

- start = perform checks and initiate a release. <version> is the argument with the version to release.

Many checks are performed including checks to make sure that necessary commands are installed,
calling check, if there is a Pipfile indicating that it's a python project then it checks
for a active virtualenv, and that a $EDITOR is set for commits.

If everything is ok, it prompts to proceed.

- then the editor is launced to update the python.sh. It is added and committed automatically.

- the release process then copies the Pipfile and Pipfile.lock to the release/ directory preserving the information needed to re-build the code later.

- the git flow release command then drops back to the shell to inspect the release.

At this point release packages can be built and tested. If the testing
goes well the next step is to run ./py.sh release to finalise the
release.

#+BEGIN_SRC bash
./py.sh release
#+END_SRC

The release command merges the release branch back into main, and then
develop, tagging the release as well.

#+BEGIN_SRC bash
./py.sh upload
#+END_SRC

Upload is the final step: it pushes "main" "develop" and tags to
upstream.

*** Release - Building & Testing

There are two types of packages. Singular packages created by the
python build module. The second type is a buildset package which is an
abbreviation for built set. it's a zip named like a wheel, except it's
a all the runtime dependencies gathered from the test virtual
environment.

buildset packages are used when there are private packages in the mix
and we need to be able to install all the dependencies in one shot.

to start the release proccess a release environment is
created.

#+BEGIN_SRC bash
./py.sh mkrelease

switch_release

pipenv install <package>
#+END_SRC

At that point the release is tested. If the release
is deemed ok a beta is cut.

#+BEGIN_SRC bash
./py.sh tag-beta "feature" "message"

switch_release

pipenv install <package>
#+END_SRC

Code takes time bake, and so rushing into a release
is not a good idea. after some time has passed and
a few final fixes are made it's time for the
full release process to start.

#+print_bibliography:
